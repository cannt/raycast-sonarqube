import { isSonarQubeRunning } from "./utils";
import * as http from "http";
import { IncomingMessage, ClientRequest } from "http";
import { EventEmitter } from "events";

// Define interfaces for mock objects
interface MockResponse extends Partial<IncomingMessage> {
  statusCode: number;
  on: jest.Mock<any, any>;
}

interface MockRequest extends Partial<ClientRequest> {
  on: jest.Mock<any, any>;
  destroy: jest.Mock<any, any>;
}

type EventCallback = (data?: any) => void;

// Helper functions to create properly typed mock objects
function createMockRequest(): MockRequest {
  const mock: MockRequest = {
    on: jest.fn(),
    destroy: jest.fn()
  };
  
  // Add self-reference for method chaining
  mock.on.mockImplementation((event: string, callback?: EventCallback) => mock);
  
  return mock;
}

function createMockResponse(statusCode = 200): MockResponse {
  const mock: MockResponse = {
    statusCode,
    on: jest.fn()
  };
  
  // Add self-reference for method chaining
  mock.on.mockImplementation((event: string, callback?: EventCallback) => {
    return mock;
  });
  
  return mock;
}

// Mock the http module
jest.mock("http");

// Define types for the mock callbacks
type DataCallback = (chunk: string) => void;
type EndCallback = () => void;
type ErrorCallback = (error: Error) => void;

describe("utils.ts - direct branch coverage improvements", () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });
  
  describe("isSonarQubeRunning - branch coverage", () => {
    it("should handle successful response with UP status (non-detailed mode)", async () => {
      // Setup mock response using helper function
      const mockResponseData = { status: "UP" };
      const mockResponse = createMockResponse(200);
      
      // Configure mock response behavior
      mockResponse.on.mockImplementation((event: string, callback?: EventCallback) => {
        if (event === 'data' && callback) {
          setTimeout(() => callback(JSON.stringify(mockResponseData)), 10);
        } else if (event === 'end' && callback) {
          setTimeout(() => callback(), 20);
        }
        return mockResponse;
      });
      
      // Setup the mock request
      const mockRequest = createMockRequest();
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: false });
      expect(result).toBe(true);
    });
    
    it("should handle successful response with UP status (detailed mode)", async () => {
      // Setup the mock response objects
      const mockResponseData = { status: "UP" };
      const mockResponse: MockResponse = {
        statusCode: 200,
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'data' && callback) {
            setTimeout(() => callback(JSON.stringify(mockResponseData)), 10);
          } else if (event === 'end' && callback) {
            setTimeout(() => callback(), 20);
          }
          return mockResponse;
        })
      };
      
      // Setup the mock request
      const mockRequest: MockRequest = {
        on: jest.fn((event: string, callback?: EventCallback) => mockRequest),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: true });
      expect(result).toEqual({
        running: true,
        status: "running",
        details: "SonarQube is running normally"
      });
    });
    
    it("should handle successful response with starting status (detailed mode)", async () => {
      // Setup the mock response objects
      const mockResponseData = { status: "starting" };
      const mockResponse: MockResponse = {
        statusCode: 200,
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'data' && callback) {
            setTimeout(() => callback(JSON.stringify(mockResponseData)), 10);
          } else if (event === 'end' && callback) {
            setTimeout(() => callback(), 20);
          }
          return mockResponse;
        })
      };
      
      // Setup the mock request
      const mockRequest = {
        on: jest.fn((event, callback) => mockRequest),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: true });
      expect(result).toEqual({
        running: false,
        status: "starting",
        details: "SonarQube is still starting up"
      });
    });
    
    it("should handle successful response with unknown status (detailed mode)", async () => {
      // Setup the mock response objects
      const mockResponseData = { status: "unknown" };
      const mockResponse: MockResponse = {
        statusCode: 200,
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'data' && callback) {
            setTimeout(() => callback(JSON.stringify(mockResponseData)), 10);
          } else if (event === 'end' && callback) {
            setTimeout(() => callback(), 20);
          }
          return mockResponse;
        })
      };
      
      // Setup the mock request
      const mockRequest = {
        on: jest.fn((event, callback) => mockRequest),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: true });
      expect(result).toEqual({
        running: false,
        status: "unknown_success_response", 
        details: "SonarQube returned status: unknown"
      });
    });
    
    it("should handle 503 service unavailable response (detailed mode)", async () => {
      // Setup the mock response objects
      const mockResponse: MockResponse = {
        statusCode: 503,
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'data' && callback) {
            setTimeout(() => callback("Service Unavailable"), 10);
          } else if (event === 'end' && callback) {
            setTimeout(() => callback(), 20);
          }
          return mockResponse;
        })
      };
      
      // Setup the mock request
      const mockRequest = createMockRequest();
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: true });
      expect(result).toEqual({
        running: false,
        status: "starting",
        details: "SonarQube is still starting up"
      });
    });
    
    it("should handle connection refused error (detailed mode)", async () => {
      // Setup the mock request with error behavior
      const mockRequest: MockRequest = {
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'error' && callback) {
            setTimeout(() => callback(new Error("ECONNREFUSED")), 10);
          }
          return mockRequest;
        }),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation(() => mockRequest);
      
      const result = await isSonarQubeRunning({ detailed: true, retries: 0 });
      expect(result).toEqual({
        running: false,
        status: "down",
        details: "SonarQube server is not running"
      });
    });
    
    it("should handle timeout error (detailed mode)", async () => {
      // Setup the mock request with timeout behavior
      const mockRequest: MockRequest = {
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'timeout' && callback) {
            setTimeout(() => callback(), 10);
          }
          return mockRequest;
        }),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation(() => mockRequest);
      
      const result = await isSonarQubeRunning({ detailed: true, retries: 0 });
      expect(result).toEqual({
        running: false,
        status: "timeout",
        details: "SonarQube server is not responding (may be starting)"
      });
    });
    
    it("should detect timeout errors with regex match (detailed mode)", async () => {
      // Setup the mock request with timeout error that contains "timeout" 
      const mockRequest: MockRequest = {
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'error' && callback) {
            setTimeout(() => callback(new Error("Operation timeout after 3000ms")), 10);
          }
          return mockRequest;
        }),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation(() => mockRequest);
      
      const result = await isSonarQubeRunning({ detailed: true, retries: 0 });
      expect(result).toEqual({
        running: false,
        status: "timeout",
        details: "SonarQube server is not responding (may be starting)"
      });
    });
    
    it("should handle invalid JSON response with 200 status (detailed mode)", async () => {
      // Setup the mock response objects
      const mockResponse: MockResponse = {
        statusCode: 200,
        on: jest.fn((event: string, callback?: EventCallback) => {
          if (event === 'data' && callback) {
            setTimeout(() => callback("Not valid JSON"), 10);
          } else if (event === 'end' && callback) {
            setTimeout(() => callback(), 20);
          }
          return mockResponse;
        })
      };
      
      // Setup the mock request
      const mockRequest = {
        on: jest.fn((event, callback) => mockRequest),
        destroy: jest.fn()
      };
      
      // Mock the http.get implementation
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        if (callback) {
          process.nextTick(() => callback(mockResponse));
        }
        return mockRequest;
      });
      
      const result = await isSonarQubeRunning({ detailed: true });
      expect(result).toEqual({
        running: true,
        status: "running",
        details: "SonarQube is running normally"
      });
    });
    
    it("should retry specified number of times on failure", async () => {
      // Track call counts
      let callCount = 0;
      
      // First call will fail, second call succeeds
      (http.get as jest.Mock).mockImplementation((options, callback) => {
        callCount++;
        
        const mockRequest: MockRequest = {
          on: jest.fn((event: string, callback?: EventCallback) => mockRequest),
          destroy: jest.fn()
        };
        
        if (callCount === 1) {
          // First call fails with error
          process.nextTick(() => {
            if (mockRequest.on.mock.calls.find((call: any) => call[0] === 'error')) {
              const errorCallback = mockRequest.on.mock.calls.find((call: any) => call[0] === 'error')[1];
              errorCallback(new Error("Temporary error"));
            }
          });
          return mockRequest;
        } else {
          // Second call succeeds
          const mockResponse: MockResponse = {
            statusCode: 200,
            on: jest.fn((event: string, callback?: EventCallback) => {
              if (event === 'data' && callback) {
                setTimeout(() => callback(JSON.stringify({ status: "UP" })), 10);
              } else if (event === 'end' && callback) {
                setTimeout(() => callback(), 20);
              }
              return mockResponse;
            })
          };
          
          if (callback) {
            process.nextTick(() => callback(mockResponse));
          }
          return mockRequest;
        }
      });
      
      // Mock setTimeout to execute immediately
      const originalSetTimeout = global.setTimeout;
      global.setTimeout = jest.fn().mockImplementation((fn) => {
        fn();
        return 1; // timer id
      }) as unknown as typeof global.setTimeout;
      
      // Add the __promisify__ property to match the setTimeout interface
      (global.setTimeout as any).__promisify__ = jest.fn();
      
      const result = await isSonarQubeRunning({ detailed: false, retries: 1 });
      
      // Restore original setTimeout
      global.setTimeout = originalSetTimeout;
      
      expect(callCount).toBe(2);
      expect(result).toBe(true);
    });
  });
});
